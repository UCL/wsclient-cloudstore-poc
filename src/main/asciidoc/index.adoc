= wsclient-cloudstore-poc
David Guzman <https://github.com/david-guzman[@david-guzman]>
:revnumber: {project-version}
:revdate: 12.01.2018
:revremark: First draft
:toc: macro
:toc-title: Contents

Java EE Timer-based JAX-RS client to cloud file store application to facilitate analysis of text content obtained from APIs (proof of concept).

*Source code:* https://github.com/UCL/wsclient-cloudstore-poc

.DRAFT
****
This document is only a rough draft.
These recommendations are subject to change.
****

toc::[]

== Background

=== Context

=== Objectives

=== Resources and platforms

==== Data sources

This proof-of-concept application is designed to retrieve JSON data from a REST endpoint such as Twitter and Instagram APIs.

IMPORTANT: This implementation does not support the use of "Streaming" APIs.

==== PaaS - Heroku

While the `wsclient-app` module can be deployed in an existing installation of a Java EE 8 server like Glassfieh 5. This proof-of-concept
uses the public PaaS https://www.heroku.com/[Heroku]

Heroku uses `dynos`, lightweight Linuz application containers pre-configured for specific process types. The free account allows 1 worker/1 web process types.
This proof-of-concept uses a worker `dyno`.

For more information on Heroku https://devcenter.heroku.com/articles/how-heroku-works

Heroku allows the deployment of applications from sources in an existing Github repository. With its CLI, the process would be

....
heroku login
git clone git@github.com:UCL/wsclient-cloudstore-poc.git
cd wsclient-cloudstore-poc
heroku create wsclient-cloudstore-poc-ly4y5z
....

The last command will create an instance on Heroku with its own Git repository, which is added as a remote to the user:

....
$ git remote -v
heroku	https://git.heroku.com/wsclient-cloudstore-poc-ly4y5z.git (fetch)
heroku	https://git.heroku.com/wsclient-cloudstore-poc-ly4y5z.git (push)
origin	git@github.com:UCL/wsclient-cloudstore-poc.git (fetch)
origin	git@github.com:UCL/wsclient-cloudstore-poc.git (push)
....

Deployment of the application is done with:
....
heroku push heroku master
....

This instructs Heroku to build the application using Maven, unless Maven Wrapper is detected, in which case `mvnw` will be used instead.

.OpenShift
****
In addition to Heroku, OpenShift is another PaaS system that should be considered. OpenShift is a RedHat product
based on Docker and Kubernetes available in 3 configurations: hosted (online), dedicated (public cloud) and on-premise. This last option could be worth
exploring for a local installation within CS UCL.

For more information on OpenShirt https://www.openshift.com/
****

==== UCL Office365 OneDrive

== Core components

=== wsclient-app

The `wsclient-app` application is an EJB module based in Java EE 8 technologies (Glassfish 5):

* EJB Timer
* CDI events
* JSONB and JSONP
* JAXRS client (NB: at moment it is implemented using Jersey-specific features)

==== Business logic

The complete process should be transactional and must complete the following tasks:

. Download JSON data from public REST endpoints such as Twitter Search API
. Package the serialised JSON data in a temporary compressed ZIP file
. Upload to UCL OneDrive using a MS Graph REST endpoint

The process is orchestrated by the EJB Timer service. In this proof of concept, the interval to use is of 1 hour.
Once the timeout has been reached, a CDI event with a qualifier specific to a REST client is fired.

The complete process is represented in the following sequence diagram:

[plantuml, wsclient-sequence, svg]
....
box "wsclient-app"
control CallTimer <<Singleton EJB>>
control TwitterCall <<Stateless EJB>>
control FileStore <<Stateless EJB>>
control MsGraphCall <<Stateless EJB>>
end box
collections PubAPIs as "Public APIs" <<HTTP Resource>>

CallTimer -> CallTimer : @PostConstruct start timer
activate CallTimer

CallTimer --> TwitterCall: @Timeout fire event
activate CallTimer
activate TwitterCall
CallTimer -> CallTimer: next @Timeout
deactivate CallTimer

TwitterCall ->] : <<Request>>
ref over PubAPIs: Twitter API
TwitterCall <-] : <<Response>>
TwitterCall -> FileStore : store serialised JSON
activate FileStore

FileStore -> FileStore : create ZIP file
activate FileStore
FileStore -> MsGraphCall : upload ZIP file
activate MsGraphCall
MsGraphCall ->] : <<Request>>
ref over PubAPIs: MS Graph API
MsGraphCall <-] : <<Response>>
deactivate MsGraphCall
FileStore -> FileStore : delete ZIP file
deactivate FileStore
deactivate FileStore
deactivate TwitterCall
....

Since the source endpoint is queried to return data for a specific day, the application could could store in a 
cache object a flag to indicate when the transaction has been completed successfully to prevent the REST client to 
call the source endpoint repeatedly every hour. This is represented in the following activity diagram:

[plantuml, control-iterations, svg]
....
(*) --> "@Observes timed event\n extract date from event info"
if "Date in event equals date in cache?" then
--> [false] "Call remote REST endpoint"
--> "Package and compress in ZIP"
--> "Upload to UCL OneDrive"
if "MS Graph API returns 501?" then
--> [true] "Store date in cache"
endif
....

=== wsclient-main

The `wsclient-main` module allows the deployment of `wsclient-app` in environments where a Java EE 8 server is not available. `wsclient-main` uses Glassfish 5 embedded to run `wsclient-app`. The build process generates a shell script that can be used to configure and run the application in standalone mode in Glassfish embedded.

....
sh wsclient-main/target/app/bin/glassfish5
....

This script allows the deployment of `wsclient-app` in Heroku as a worker dyno, as defined in the `Procfile`:

....
worker: sh wsclient-main/target/app/bin/glassfish5
....

== Data model

=== Query parameters

==== Query terms

==== Location

=== JSON object

== Data flow

[plantuml, dataflow, svg]
....
cloud "Internet" {
    [Twitter API] -- GET
    GET --> [wsclient-cloudstore-app]
    [wsclient-cloudstore-app] --> PUT
    PUT -- [UCL Office365 OneDrive]
}

note right of [wsclient-cloudstore-app]
    Calls Twitter Search API
    Package and compress JSON in a ZIP file
    Push the ZIP file to OneDrive
end note

frame "CS UCL" {
    [UCL Office365 OneDrive] ..> API
    API -- [clientapp1]
    API -- [clientapp2]
    API -- [clientappn]
    
    [clientapp1] --> [data processor]
    [clientapp2] --> [data processor]
    [clientappn] --> [data processor]
    
    folder "storage" {
        [data processor] --> [objectstore]
        [data processor] --> [database]
        [data processor] --> [filestore]
        
    }
}

note right of API
    Python API
end note
....


== Future features
